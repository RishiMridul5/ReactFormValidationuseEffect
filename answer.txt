What is debouncing? What is the problem with the app if we don't use debouncing?
=> Debouncing is a technique used to ensure that time-consuming tasks such as API calls, netwoek requests do not fire so often for example on every onchange event of a input element if we want to update the validation state then the app will unneccesarily check the input value against the validation rule which actually can be done once the user has stopped/paused entering the value.

How does the udemy trainer achieve debouncing in his code?
=> By using setTimeout() which ensures that 'formIsValid state is updated only when user has paused entering in any input field.

When does the cleanup function get called
=> After every call of useEffect() 
Why do even need to have cleanup functions?
=> Clean up functions are used to perform some clean up tasks such as clearing timers, network requests made inside useEffect() etc.. from the previous render before running the effects next time.

When does the useEffect hook get called in the lifecycle. Before rendering or after rendering?
=> After rendering. useEffect() is a combination of componentDidMount, componentDidUpdate, and componentWillUnmount combined.

When would you use useReducer and why ?
=> 
useState is good for mananging simple states. Also useState is not good to use in situations when a state depends on another state.
for example 
const[enteredEmail, setEnteredEmail] = useState('')
const [emailValid, setEmailValid] = useState(true)

  const validateEmailHandler = () => {
    setEmailValid(enteredEmail.includes("@"));
  };
In the above code emailValid state depends on the value entered by the user i.e enteredEmail's value. Here in the above code it is not a big problem and it will work or more specifically we could write
  const validateEmailHandler = () => {
    if(enteredEmail.includes("@"))
        setEmailValid(true);
  };
But in situations where we are setting a state based on 2 or more different states it could lead to problem.
In some cases we need to update a state depending on previous state snapshot and the previous state snapshot should be exactly of the same state, not for different states. 
For example
    const [formIsValid, setFormIsValid] = useState(false);
     setFormIsValid(
        enteredEmail.includes("@") &&
          enteredPassword.trim().length > 6 &&
          enteredCollege.trim().length < 5
      );
    In the above code if we want to change the 'formIsValid' state based on the previous state using callback syntax of useState then we cannot do so. To do so we must have to use the previous state snapshot of formIsValid state

     setFormIsValid((enteredEmail, enteredPassword, enteredCollege )
        enteredEmail.includes("@") &&
          enteredPassword.trim().length > 6 &&
          enteredCollege.trim().length < 5
      );

    Also, enteredEmail/enteredPassword/enteredCollege states might not have been updated when setFormIsValid is called since react does not perform state updates instantly.

    So, we should use useReducer() when 
    1. Two states have a corelation between them i.e one state variable have some relationship with the other and they can be interlinked together.
    2. When a state depends on the previous state snapshot and we need to use some other state variable to determine the state of that state.

Why do we create the emailReducer outside the functional component and not inside it?
=> emailReducer does not need any data that are generated inside the component function so we can declare it outside the scope of component function. The arguments it receives is automatically generated by the react.

What does the emailReducer do. Please explain
=>
emailReducer receives two arguments state and action. state is the previous snapshot and action recieves a value (here object) dispatched by the respective dispatcher.

How does dispatch actions work.
=> dispatch function is used to dispatch an action to the reducer function Based on the action provided the state gets updated i.e React passes the current state and the dispatched action to the reducer and the reducer uses the action to update the state and returns the new version.
